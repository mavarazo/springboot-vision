# ADR 0003: Transaction Management and DTO Usage Strategy

## Status
Accepted

## Context
In modern enterprise Spring applications, it's crucial to have a clear strategy for transaction management and data mapping across layers. Inconsistent placement of transaction boundaries can lead to database connection leaks, lazy loading exceptions, or inconsistent data states. Furthermore, exposing internal entities (JPA/Hibernate) directly through controllers creates tight coupling between the database schema and the public API, making it difficult to change either without breaking the other.

## Decision
We will adhere to the following architectural rules:

1.  **Transaction Boundaries in Service Layer**: Transactions must only be opened at the business service level (e.g., using `@Transactional`). This ensures that a single business operation is atomic and that resources are managed efficiently. Controllers must never open or manage transactions.
2.  **DTOs for Simple Use Cases**: For simple CRUD-like operations or straightforward business logic, services should directly accept and return the DTOs generated by the OpenAPI contract. This reduces mapping overhead and simplifies the development flow.
3.  **Business Records for Complex Use Cases**: As business logic grows in complexity (e.g., involving multiple domain entities or external systems), services should transition to using internal **Java Records** as business models. This decouples the core domain logic from the public API structure.
4.  **No Entity Leakage**: Internal database entities (e.g., `@Entity` classes) must never be returned to or accepted by controllers. They must be mapped to DTOs (or business records) within the service layer before being passed back to the controller.
5.  **Evolutionary Architecture**: We treat the usage of API DTOs in the service layer as an evolutionary approach. We start simple and only introduce mapping to internal records when the complexity of the use case justifies the extra abstraction layer.

## Rationale
1.  **Atomicity and Integrity**: Placing transactions in the service layer ensures that all database operations within a business use case succeed or fail together.
2.  **Decoupling**: Preventing entity leakage ensures that the API contract remains stable even if the database schema changes.
3.  **Maintainability**: Java Records provide a lightweight, immutable way to represent business data without the overhead of JPA entities or the coupling of API DTOs in complex scenarios.
4.  **Pragmatism**: Allowing API DTOs in the service layer for simple cases prevents over-engineering and reduces boilerplate code, while the path to a more robust domain model remains open as the application evolves.

## Consequences
- **Positive**: Reduced boilerplate for simple features, clear separation of concerns, and robust transaction management.
- **Negative**: Requires careful mapping in complex scenarios to ensure entities don't accidentally leak.
